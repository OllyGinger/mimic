# The Sharp LR35902 (AKA SM83) is the CPU that's found inside the original Gameboy. This is almost the same as a Z80, but 
# there are some gameboy specifc differences.
#
# This file describes the rules in these pages;
#   https://gbdev.io/gb-opcodes/optables/octal
#   http://www.z80.info/decoding.htm
#
#
# This CPU had blocks of 256 opcodes. For each opcode index, we split out some components in this form:
#
# MSB    (opcode idx bits)     LSB
# [7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 ]
# \      /\         /\          /
#    x         y           z
#         |      |   |
#         |   p  | q |
#
# X = Opcode 1st octal digit (bits 7-6)
# Y = Opcode 2nd octal digit (bits 5-3)
# Z = Opcode 3rd octal digit (bits 2-0)
# P = Y right shift one position (bits 5-4)
# Q = Y modulo 2 (bit 3)

# --- Quadrant 1 ---
HALT: 
  encoding: (x == 1 && y == 6 && z == 6)
  action: self.halt();

LD $RY, $RZ:
  encoding: (x == 1 && y != 6 && z != 6)
  action: 
    self.registers.inc_pc(1);
    self.registers.set_$RY(self.registers.$RZ()); 
  tests:
    - set:
        - registers.set_$RZ(0x66)
      expect:
        - [registers.$RY(), 0x66]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - registers.set_$RZ(0x66)
        - registers.enable_all_flags()
      expect:
        - [registers.$RY(), 0x66]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

LD (HL), $RZ:
  encoding: (x == 1 && y == 6 && z != 6)
  mcycle_duration: 2
  action: 
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), self.registers.$RZ()); 
  tests:
    - set:
        - registers.set_$RZ(0xff)
        - registers.set_hl(0xffff)
      expect:
        - [mmu.read8(0xffff), 0xff]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - registers.set_$RZ(0xff)
        - registers.set_hl(0xffff)
        - registers.enable_all_flags()
      expect:
        - [mmu.read8(0xffff), 0xff]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

LD $RY, (HL):
  encoding: (x == 1 && y != 6 && z == 6)
  mcycle_duration: 2
  action: 
    self.registers.inc_pc(1);
    self.registers.set_$RY(self.mmu.read8(self.registers.hl()));
  tests:
    - set:
        - mmu.write8(0xffff, 0xAB)
        - registers.set_hl(0xffff)
      expect:
        - [registers.$RY(), 0xAB]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - mmu.write8(0xffff, 0xAB)
        - registers.set_hl(0xffff)
        - registers.enable_all_flags()
      expect:
        - [registers.$RY(), 0xAB]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# --- Quadrant 2 ---
$ALU (HL):
  encoding: (x == 2) && (z == 6)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.alu_$ALU(self.mmu.read8(self.registers.hl()));

$ALU $RZ:
  encoding: (x == 2) && (z != 6)
  action:
    self.registers.inc_pc(1);
    self.alu_$ALU(self.registers.$RZ());

# --- Quadrant 0 ---
NOP:
  encoding: (x == 0 && y == 0 && z == 0)
  action:
    self.registers.inc_pc(1);
  tests:
    - expect:
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags()
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01] 

# 8 bit inc/dec
INC $RY:
  encoding: (x == 0 && y != 6 && z == 4)
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.inc8(self.registers.$RY());
    self.registers.set_$RY(val); 
    self.registers.set_flags(flags);
  tests:
    - set:
        - registers.set_$RY(0xFE)
      expect:
        - [registers.$RY(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RY(0xFF)
      expect:
        - [registers.$RY(), 0x00]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

INC (HL):
  encoding: (x == 0 && y == 6 && z == 4)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.inc8(self.mmu.read8(self.registers.hl()));
    self.registers.set_flags(flags);
    self.mmu.write8(self.registers.hl(), val); 
  tests:
    - set:
        - mmu.write8(0xff00, 0xDE)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xDF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

DEC $RY:
  encoding: (x == 0 && y != 6 && z == 5)
  action:
    self.registers.inc_pc(1);
    self.registers.set_$RY(self.registers.$RY().wrapping_sub(1)); 
  tests:
    - set:
        - registers.set_$RY(0xFF)
      expect:
        - [registers.$RY(), 0xFE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
DEC (HL):
  encoding: (x == 0 && y == 6 && z == 5)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), self.mmu.read8(self.registers.hl()).wrapping_sub(1)); 
  tests:
    - set:
        - mmu.write8(0xff00, 0xDF)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xDE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
# 16 bit inc/dec
INC $RRP:
  encoding: (x == 0 && z == 3 && q == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_$RRP(self.registers.$RRP().wrapping_add(1));
  tests:
    - set:
        - registers.set_$RRP(0xABCD)
      expect:
        - [registers.$RRP(), 0xABCE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

DEC $RRP:
  encoding: (x == 0 && z == 3 && q == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_$RRP(self.registers.$RRP().wrapping_sub(1));
  tests:
    - set:
        - registers.set_$RRP(0xABCD)
      expect:
        - [registers.$RRP(), 0xABCC]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

# 16 bit immediate load
ADD HL, $RRP:
  encoding: (x == 0 && z == 1 && q == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.alu_add_hl(self.registers.$RRP());
LD $RRP, n16:
  encoding: (x == 0 && z == 1 && q == 0)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read16(self.registers.pc());
    self.registers.inc_pc(2);
    self.registers.set_hl(imm);

# 8 bit Load literal
LD $RY, n8:
  encoding: (x == 0 && y != 6 && z == 6)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc());
    self.registers.inc_pc(1);
    self.registers.set_$RY(imm);
LD (HL), n8:
  encoding: (x == 0 && y == 6 && z == 6)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc());
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), imm);

# 16 bit indirect loads
LD (BC), A:
  encoding: (x == 0 && z == 2 && q == 0 && p == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.bc(), self.registers.a());
LD A, (BC):
  encoding: (x == 0 && z == 2 && q == 1 && p == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.bc()));
LD (DE), A:
  encoding: (x == 0 && z == 2 && q == 0 && p == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.de(), self.registers.a());
LD A, (DE):
  encoding: (x == 0 && z == 2 && q == 1 && p == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.de()));
