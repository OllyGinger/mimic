# The Sharp LR35902 (AKA SM83) is the CPU that's found inside the original Gameboy. This is almost the same as a Z80, but 
# there are some gameboy specifc differences.
#
# This file describes the rules in these pages;
#   https://gbdev.io/gb-opcodes/optables/octal
#   http://www.z80.info/decoding.htm
#
#
# This CPU had blocks of 256 opcodes. For each opcode index, we split out some components in this form:
#
# MSB    (opcode idx bits)     LSB
# [7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 ]
# \      /\         /\          /
#    x         y           z
#         |      |   |
#         |   p  | q |
#
# X = Opcode 1st octal digit (bits 7-6)
# Y = Opcode 2nd octal digit (bits 5-3)
# Z = Opcode 3rd octal digit (bits 2-0)
# P = Y right shift one position (bits 5-4)
# Q = Y modulo 2 (bit 3)

# --- Quadrant 1 ---
# Flags: - - - -
HALT: 
  encoding: (x == 1 && y == 6 && z == 6)
  action: self.halt();

# Flags: - - - -
LD $RY, $RZ:
  encoding: (x == 1 && y != 6 && z != 6)
  action: 
    self.registers.inc_pc(1);
    self.registers.set_$RY(self.registers.$RZ()); 
  tests:
    - set:
        - registers.set_$RZ(0x66)
      expect:
        - [registers.$RY(), 0x66]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - registers.set_$RZ(0x66)
        - registers.enable_all_flags()
      expect:
        - [registers.$RY(), 0x66]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# Flags: - - - -
LD (HL), $RZ:
  encoding: (x == 1 && y == 6 && z != 6)
  mcycle_duration: 2
  action: 
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), self.registers.$RZ()); 
  tests:
    - set:
        - registers.set_$RZ(0xff)
        - registers.set_hl(0xffff)
      expect:
        - [mmu.read8(0xffff), 0xff]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - registers.set_$RZ(0xff)
        - registers.set_hl(0xffff)
        - registers.enable_all_flags()
      expect:
        - [mmu.read8(0xffff), 0xff]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# Flags: - - - -
LD $RY, (HL):
  encoding: (x == 1 && y != 6 && z == 6)
  mcycle_duration: 2
  action: 
    self.registers.inc_pc(1);
    self.registers.set_$RY(self.mmu.read8(self.registers.hl()));
  tests:
    - set:
        - mmu.write8(0xffff, 0xAB)
        - registers.set_hl(0xffff)
      expect:
        - [registers.$RY(), 0xAB]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set: # Check flags aren't messed with
        - mmu.write8(0xffff, 0xAB)
        - registers.set_hl(0xffff)
        - registers.enable_all_flags()
      expect:
        - [registers.$RY(), 0xAB]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# --- Quadrant 2 ---
# ADD Flags: Z 0 H C
# SUB Flags: Z 1 H C
# AND Flags: Z 0 1 0
# XOR Flags: Z 0 0 0
# CP Flags: Z 1 H C
$ALU (HL):
  encoding: (x == 2) && (z == 6)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.alu_$ALU(self.mmu.read8(self.registers.hl()));

$ALU $RZ:
  encoding: (x == 2) && (z != 6)
  action:
    self.registers.inc_pc(1);
    self.alu_$ALU(self.registers.$RZ());

# --- Quadrant 0 ---
# Flags: - - - -
NOP:
  encoding: (x == 0 && y == 0 && z == 0)
  action:
    self.registers.inc_pc(1);
  tests:
    - expect:
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags()
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01] 

# 8 bit inc/dec
# Flags: Z 0 H -
INC $RY:
  encoding: (x == 0 && y != 6 && z == 4)
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.inc8(self.registers.$RY());
    self.registers.set_$RY(val); 
    self.registers.set_flags(flags);
  tests:
    - set:
        - registers.set_$RY(0xFE)
      expect:
        - [registers.$RY(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RY(0xFF)
      expect:
        - [registers.$RY(), 0x00]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RY(0xEF)
      expect:
        - [registers.$RY(), 0xF0]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

# Flags: Z 0 H -
INC (HL):
  encoding: (x == 0 && y == 6 && z == 4)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.inc8(self.mmu.read8(self.registers.hl()));
    self.registers.set_flags(flags);
    self.mmu.write8(self.registers.hl(), val); 
  tests:
    - set:
        - mmu.write8(0xff00, 0xDE)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xDF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - mmu.write8(0xff00, 0xEF)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xF0]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

# Flags: Z 1 H -
DEC $RY:
  encoding: (x == 0 && y != 6 && z == 5)
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.dec8(self.registers.$RY());
    self.registers.set_$RY(val); 
    self.registers.set_flags(flags);
  tests:
    - set:
        - registers.set_$RY(0xFF)
      expect:
        - [registers.$RY(), 0xFE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RY(0x00)
      expect:
        - [registers.$RY(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RY(0x01)
      expect:
        - [registers.$RY(), 0x00]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
# Flags: Z 1 H -
DEC (HL):
  encoding: (x == 0 && y == 6 && z == 5)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let (val, flags) = self.dec8(self.mmu.read8(self.registers.hl()));
    self.registers.set_flags(flags);
    self.mmu.write8(self.registers.hl(), val); 
  tests:
    - set:
        - mmu.write8(0xff00, 0xDF)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xDE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - mmu.write8(0xff00, 0xF0)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0xEF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - mmu.write8(0xff00, 0x01)
        - registers.set_hl(0xff00)
      expect:
        - [registers.hl(), 0xff00]
        - [mmu.read8(0xff00), 0x00]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
# 16 bit inc/dec
# Flags: - - - -
INC $RRP:
  encoding: (x == 0 && z == 3 && q == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_$RRP(self.registers.$RRP().wrapping_add(1));
  tests:
    - set:
        - registers.set_$RRP(0xABCD)
      expect:
        - [registers.$RRP(), 0xABCE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RRP(0xABCD)
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.$RRP(), 0xABCE]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]
# Flags: - - - -
DEC $RRP:
  encoding: (x == 0 && z == 3 && q == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_$RRP(self.registers.$RRP().wrapping_sub(1));
  tests:
    - set:
        - registers.set_$RRP(0xABCD)
      expect:
        - [registers.$RRP(), 0xABCC]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RRP(0xABCD)
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.$RRP(), 0xABCC]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# 16 bit immediate load
# Flags: - 0 H C
ADD HL, $RRP:
  encoding: (x == 0 && z == 1 && q == 1 && y != 5) # Split the `ADD HL, HL` into it's own encoding so we can customise the tests
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.alu_add_hl(self.registers.$RRP());
  tests:
    - set:
        - registers.set_$RRP(0x1111)
        - registers.set_hl(0xABCD)
      expect:
        - [registers.hl(), 0xBCDE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RRP(0x0001)
        - registers.set_hl(0x0FFF)
      expect:
        - [registers.hl(), 0x1000]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.set_$RRP(0x0001)
        - registers.set_hl(0xFFFF)
      expect:
        - [registers.hl(), 0x0000]
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        - [registers.pc(), 0x01]

# Flags: - 0 H C
ADD HL, HL:
  encoding: (x == 0 && z == 1 && q == 1 && y == 5)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.alu_add_hl(self.registers.hl());
  tests:
    - set:
        - registers.set_hl(0x1234)
      expect:
        - [registers.hl(), 0x2468]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]

# Flags: - - - -
LD $RRP, n16:
  encoding: (x == 0 && z == 1 && q == 0)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read16(self.registers.pc());
    self.registers.inc_pc(2);
    self.registers.set_$RRP(imm);
  tests:
    - set:
        - mmu.write16(0x0001, 0x1234)
      expect:
        - [registers.$RRP(), 0x1234]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x03]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        
# 8 bit Load literal
# Flags: - - - -
LD $RY, n8:
  encoding: (x == 0 && y != 6 && z == 6)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc());
    self.registers.inc_pc(1);
    self.registers.set_$RY(imm);
  tests:
    - set:
        - mmu.write8(0x01, 0xAB)
      expect:
        - [registers.$RY(), 0xAB]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x02]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
        
# Flags: - - - -
LD (HL), n8:
  encoding: (x == 0 && y == 6 && z == 6)
  mcycle_duration: 3
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc());
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), imm);
  tests:
    - set:
        - registers.set_hl(0x0F00)
        - mmu.write8(0x01, 0xFF)
      expect:
        - [mmu.read8(0x0F00), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x02]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# 16 bit indirect loads
# Flags: - - - -
LD (BC), A:
  encoding: (x == 0 && z == 2 && q == 0 && p == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.bc(), self.registers.a());
  tests:
    - set:
        - registers.set_bc(0x0F00)
        - registers.set_a(0xFF)
      expect:
        - [mmu.read8(0x0F00), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# Flags: - - - -
LD A, (BC):
  encoding: (x == 0 && z == 2 && q == 1 && p == 0)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.bc()));
  tests:
    - set:
        - registers.set_bc(0x0F00)
        - mmu.write8(0x0F00, 0xFF)
      expect:
        - [registers.a(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# Flags: - - - -
LD (DE), A:
  encoding: (x == 0 && z == 2 && q == 0 && p == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.de(), self.registers.a());
  tests:
    - set:
        - registers.set_de(0x0F00)
        - registers.set_a(0xFF)
      expect:
        - [mmu.read8(0x0F00), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# Flags: - - - -
LD A, (DE):
  encoding: (x == 0 && z == 2 && q == 1 && p == 1)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.de()));
  tests:
    - set:
        - registers.set_de(0x0F00)
        - mmu.write8(0x0F00, 0xFF)
      expect:
        - [registers.a(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# Flags: - - - -
LD (HL+), A:
  encoding: (x == 0 && y == 4 && z == 2)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), self.registers.a());
    self.registers.set_hl(self.registers.hl().wrapping_add(1));
  tests:
    - set:
        - registers.set_hl(0x0F00)
        - registers.set_a(0xFF)
      expect:
        - [mmu.read8(0x0F00), 0xFF]
        - [registers.hl(), 0x0F01]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
# Flags: - - - -
LD (HL-), A:
  encoding: (x == 0 && y == 6 && z == 2)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.mmu.write8(self.registers.hl(), self.registers.a());
    self.registers.set_hl(self.registers.hl().wrapping_sub(1));
  tests:
    - set:
        - registers.set_hl(0x0F00)
        - registers.set_a(0xFF)
      expect:
        - [mmu.read8(0x0F00), 0xFF]
        - [registers.hl(), 0x0EFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
# Flags: - - - -
LD A, (HL+):
  encoding: (x == 0 && y == 5 && z == 2)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.hl()));
    self.registers.set_hl(self.registers.hl().wrapping_add(1));
  tests:
    - set:
        - registers.set_hl(0x0F00)
        - mmu.write8(0x0F00, 0xFF)
      expect:
        - [registers.a(), 0xFF]
        - [registers.hl(), 0x0F01]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]
# Flags: - - - -
LD A, (HL-):
  encoding: (x == 0 && y == 7 && z == 2)
  mcycle_duration: 2
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(self.mmu.read8(self.registers.hl()));
    self.registers.set_hl(self.registers.hl().wrapping_sub(1));
  tests:
    - set:
        - registers.set_hl(0x0F00)
        - mmu.write8(0x0F00, 0xFF)
      expect:
        - [registers.a(), 0xFF]
        - [registers.hl(), 0x0EFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
        - [registers.pc(), 0x01]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# 0 0 0 C
RLCA:
  encoding: (x == 0 && y == 0 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.alu_rlca();
  tests:
    - set:
        - registers.set_a(0x01)
      expect:
        - [registers.a(), 0x02]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]     
    - set:
        - registers.set_a(0x7f)
      expect:
        - [registers.a(), 0xFE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]        
    - set:
        - registers.set_a(0xFE)
      expect:
        - [registers.a(), 0xFD]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]  

# 0 0 0 C
RLA:
  encoding: (x == 0 && y == 2 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.alu_rla();
  tests:
    - set:
        - registers.set_a(0x01)
      expect:
        - [registers.a(), 0x02]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - registers.set_a(0x01)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0x03]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - registers.set_a(0x7f)
      expect:
        - [registers.a(), 0xFE]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - registers.set_a(0x7f)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]      
    - set:
        - registers.set_a(0xFE)
      expect:
        - [registers.a(), 0xFC]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]
    - set:
        - registers.set_a(0xFE)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0xFD]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]

# 0 0 0 C
RRCA:
  encoding: (x == 0 && y == 1 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.alu_rrca();
  tests:
    - set:
        - registers.set_a(0x01)
      expect:
        - [registers.a(), 0x80]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]     
    - set:
        - registers.set_a(0x7f)
      expect:
        - [registers.a(), 0xBF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]        
    - set:
        - registers.set_a(0xFE)
      expect:
        - [registers.a(), 0x7F]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]  

# 0 0 0 C
RRA:
  encoding: (x == 0 && y == 3 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.alu_rra();
  tests:
    - set:
        - registers.set_a(0x01)
      expect:
        - [registers.a(), 0x00]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]
    - set:
        - registers.set_a(0x01)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0x80]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]
    - set:
        - registers.set_a(0x7f)
      expect:
        - [registers.a(), 0x3F]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]
    - set:
        - registers.set_a(0x7f)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0xBF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 1]      
    - set:
        - registers.set_a(0xFE)
      expect:
        - [registers.a(), 0x7F]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - registers.set_a(0xFE)
        - registers.set_flag_c(true);
      expect:
        - [registers.a(), 0xFF]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]

# 0 0 0 C
LD (n16), SP:
  encoding: (x == 0 && y == 1 && z == 0)
  mcycle_duration: 5
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read16(self.registers.pc());
    self.registers.inc_pc(2);
    self.mmu.write16(imm, self.registers.sp());
  tests:
    - set:
        - mmu.write16(0x1, 0xDEAF)
        - registers.set_sp(0x1234)
      expect:
        - [mmu.read16(0xDEAF), 0x1234]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - registers.enable_all_flags() # Check flags aren't touched
      expect:
        - [registers.flag_z(), 1]
        - [registers.flag_n(), 1]
        - [registers.flag_h(), 1]
        - [registers.flag_c(), 1]

# 0 0 0 C
JR n8:
  encoding: (x == 0 && y == 3 && z == 0)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc()) as i8;
    self.registers.inc_pc(1);
    self.registers.set_pc(self.registers.pc().wrapping_add(imm as u16));
  tests:
    - set:
        - mmu.write8(0x0001, 0x12)
      expect:
        - [registers.pc(), 0x14]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]
    - set:
        - mmu.write8(0x0001, 0xFF)
      expect:
        - [registers.pc(), 0x0001]
        - [registers.flag_z(), 0]
        - [registers.flag_n(), 0]
        - [registers.flag_h(), 0]
        - [registers.flag_c(), 0]

# 0 0 0 C
JR $CC-4, n8:
  encoding: (x == 0 && y >= 4 && y <= 7 && z == 0)
  conditional_duration: true
  action:
    self.registers.inc_pc(1);
    let imm = self.mmu.read8(self.registers.pc()) as i8;
    self.registers.inc_pc(1);
    if self.cc_$CC-4() {
      self.registers.set_pc(self.registers.pc().wrapping_add(imm as u16));
      mcycles = 3;
    } else {
      mcycles = 2;
    }
  # TODO:
  #tests:
  #  - set:
  #      - mmu.write8(0x0001, 0x12)
  #    expect: # False condition
  #      - [registers.pc(), 0x2]
  #      - [registers.flag_z(), 0]
  #      - [registers.flag_n(), 0]
  #      - [registers.flag_h(), 0]
  #      - [registers.flag_c(), 0]
  #  - set:
  #      - mmu.write8(0x0001, 0x12)
  #      - registers.set_flag_$CC-4(true);
  #    expect:
  #      - [registers.pc(), 0x0001]
  #      - [registers.flag_z(), 0]
  #      - [registers.flag_n(), 0]
  #      - [registers.flag_h(), 0]
  #      - [registers.flag_c(), 0]

# Z - 0 C
DAA:
  encoding: (x == 0 && y == 4 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.alu_daa();
  tests:
      # Tests verify operation table for DAA definition in http://www.z80.info/zip/z80cpu_um.pdf
      - set: # Row 0
          - registers.set_flag_c(false);
          - registers.set_flag_h(false);
          - registers.set_a(0x00);
        expect:
          - [registers.pc(), 0x1]
          - [registers.flag_c(), 0]
          - [registers.a(), 0x00]
      - set: # Row 1
          - registers.set_flag_c(false);
          - registers.set_flag_h(false);
          - registers.set_a(0x0F);
        expect:
          - [registers.pc(), 0x1]
          - [registers.flag_c(), 0]
          - [registers.a(), 0x15]
      - set: # Row 2
          - registers.set_flag_c(false);
          - registers.set_flag_h(true);
          - registers.set_a(0x00);
        expect:
          - [registers.pc(), 0x1]
          - [registers.flag_c(), 0]
          - [registers.a(), 0x06]
    # TODO: Complete these

# - 1 1 -
CPL:
  encoding: (x == 0 && y == 5 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.registers.set_a(!self.registers.a());
    self.registers.set_flag_n(true);
    self.registers.set_flag_h(true);
  tests:
      - set:
          - registers.set_a(0x00);
        expect:
          - [registers.pc(), 0x1]
          - [registers.a(), 0xFF]
          - [registers.flag_n(), 1]
          - [registers.flag_h(), 1]
          - [registers.flag_c(), 0]
          - [registers.flag_z(), 0]
      - set:
          - registers.set_a(0xFF);
        expect:
          - [registers.pc(), 0x1]
          - [registers.a(), 0x00]
          - [registers.flag_n(), 1]
          - [registers.flag_h(), 1]
          - [registers.flag_c(), 0]
          - [registers.flag_z(), 0]
      - set:
          - registers.enable_all_flags();
        expect:
          - [registers.flag_n(), 1]
          - [registers.flag_h(), 1]
          - [registers.flag_z(), 1]
          - [registers.flag_c(), 1]

# - 0 0 1
SCF:
  encoding: (x == 0 && y == 6 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.registers.set_flag_c(true);
    self.registers.set_flag_n(false);
    self.registers.set_flag_h(false);
  tests:
      - set:
          - registers.enable_all_flags();
        expect:
          - [registers.flag_n(), 0]
          - [registers.flag_h(), 0]
          - [registers.flag_z(), 1]
          - [registers.flag_c(), 1]
      - set:
        expect:
          - [registers.flag_n(), 0]
          - [registers.flag_h(), 0]
          - [registers.flag_z(), 0]
          - [registers.flag_c(), 1]

# - 0 0 C
CCF:
  encoding: (x == 0 && y == 7 && z == 7)
  mcycle_duration: 1
  action:
    self.registers.inc_pc(1);
    self.registers.set_flag_c(!self.registers.flag_c());
    self.registers.set_flag_n(false);
    self.registers.set_flag_h(false);
  tests:
      - set:
          - registers.enable_all_flags();
        expect:
          - [registers.flag_n(), 0]
          - [registers.flag_h(), 0]
          - [registers.flag_z(), 1]
          - [registers.flag_c(), 0]
      - set:
        expect:
          - [registers.flag_n(), 0]
          - [registers.flag_h(), 0]
          - [registers.flag_z(), 0]
          - [registers.flag_c(), 1]